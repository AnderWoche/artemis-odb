package com.artemis;

import static com.artemis.FluentUtil.element;
import static com.artemis.FluentUtil.Match.ONE_OF;
import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.STATIC;
import static javax.lang.model.util.ElementFilter.constructorsIn;
import static javax.lang.model.util.ElementFilter.fieldsIn;
import static javax.lang.model.util.ElementFilter.typesIn;
import static javax.tools.Diagnostic.Kind.ERROR;

import java.util.Set;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Messager;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.Types;

import org.kohsuke.MetaInfServices;

@MetaInfServices(Processor.class)
@SupportedAnnotationTypes("com.artemis.ComponentConformanceValidator")
public class ComponentValidatorProcessor extends AbstractProcessor {
	
	private static final String COMPONENT = "com.artemis.Component";
	private static final String PACKED_COMPONENT = "com.artemis.PackedComponent";
	private static final String POOLED_COMPONENT = "com.artemis.PooledComponent";
	
	@Override
	public boolean process(Set<? extends TypeElement> types, RoundEnvironment roundEnv) {
		if (roundEnv.processingOver() || types.size() == 0)
			return true;
		
		TypeElement annotation = types.iterator().next();
		for (TypeElement type: typesIn(roundEnv.getElementsAnnotatedWith(annotation))) {
			validate(type);
		}
		
		return false;
	}
	
	private void validate(TypeElement component) {
		Types typeUtils = processingEnv.getTypeUtils();
		
		TypeMirror superclass = null;
		do {
			superclass = component.getSuperclass();
			if (PACKED_COMPONENT.equals(superclass.toString())) {
				ensureZeroArgConstructor(component);
				break;
			} else if (POOLED_COMPONENT.equals(superclass.toString())) {
				ensureZeroArgConstructor(component);
				ensureNoFinalInstanceFields(component);
				break;
			} else {
				component = (TypeElement)typeUtils.asElement(component.getSuperclass());
			}
		} while (!COMPONENT.equals(superclass.toString()));
	}

	@Override
	public SourceVersion getSupportedSourceVersion() {
		return SourceVersion.latestSupported();
	}
	
	private void ensureZeroArgConstructor(TypeElement component) {
		for (ExecutableElement constructor : constructorsIn(component.getEnclosedElements())) {
			if (constructor.getParameters().isEmpty())
				return;
		}
		
		// it's still possible that a zero-arg constructor is generated by lombok or similar
		if (element(component).hasAnnotation(ONE_OF, "@lombok.NoArgsConstructor", "@lombok.RequiredArgsConstructor"))
			return;
		
		Messager messager = processingEnv.getMessager();
		messager.printMessage(ERROR, "Missing zero-argument constructor", component);
	}
	
	private void ensureNoFinalInstanceFields(TypeElement component) {
		for (VariableElement field : fieldsIn(component.getEnclosedElements())) {
			Set<Modifier> modifiers = field.getModifiers();
			if (modifiers.contains(FINAL) && !modifiers.contains(STATIC)) {
				Messager messager = processingEnv.getMessager();
				messager.printMessage(ERROR, "Instance fields must not be declared final", field);
			}
		}
	}
}
